
var Q = require("../q");
var asap = require("asap");

afterEach(function () {
    Q.onerror = null;
});

describe("Q proper", function () {

    it("returns a fulfilled promise when given a value", function () {
        expect(Q(5).isFulfilled()).toBe(true);
    });

    it("passes promises through", function () {
        var f = Q(5);
        var r = Q.reject(new Error("aaargh"));
        var p = Q.Promise(function () { });

        expect(Q(f)).toBe(f);
        expect(Q(r)).toBe(r);
        expect(Q(p)).toBe(p);
    });

});

describe("defer and then", function () {

    it("resolve before then", function (done) {
        var turn = 0;
        var deferred = Q.defer();
        deferred.resolve(10);
        deferred.promise.then(function (value) {
            expect(turn).toBe(1);
            expect(value).toBe(10);
        }).done(done, done);
        turn++;
    });

    it("reject before then", function (done) {
        var turn = 0;
        var deferred = Q.defer();
        deferred.reject(-1);
        deferred.promise.then(function () {
            expect(true).toBe(false);
        }, function (value) {
            expect(turn).toBe(1);
            expect(value).toBe(-1);
        }).done(done, done);
        turn++;
    });

    it("when before resolve", function (done) {
        var turn = 0;
        var deferred = Q.defer();
        deferred.promise.then(function (value) {
            expect(turn).toBe(2);
            expect(value).toBe(10);
            turn++;
        }).done(done, done);
        asap(function () {
            expect(turn).toBe(1);
            deferred.resolve(10);
            turn++;
        });
        turn++;
    });

    it("then before reject", function (done) {
        var turn = 0;
        var deferred = Q.defer();
        deferred.promise.then(function () {
            expect(true).toBe(false);
        }, function (value) {
            expect(turn).toBe(2);
            expect(value).toBe(-1);
            turn++;
        })
        .done(done, done);
        asap(function () {
            expect(turn).toBe(1);
            deferred.reject(-1);
            turn++;
        });
        turn++;
    });

    it("resolves multiple handlers", function (done) {
        var nextTurn = false;

        var resolution = "Taram pam param!";
        var deferred = Q.defer();
        var count = 10;
        var i = 0;

        function resolve(value) {
            i++;
            expect(value).toBe(resolution);
            expect(nextTurn).toBe(true);
            if (i === count) {
                done();
            }
        }

        while (++i <= count) {
            deferred.promise.then(resolve);
        }

        deferred.resolve(resolution);
        i = 0;
        nextTurn = true;
    });

    it("handlers called even after throw", function (done) {
        var threw = false;
        var deferred = Q.defer();
        deferred.promise.then(function () {
            threw = true;
            throw new Error(REASON);
        });
        deferred.promise.then(function (value) {
            expect(value).toBe(10);
        }, function () {
            expect("not").toBe("here");
        }).done(done, done);
        deferred.resolve(10);
    });

    it("returns `undefined` from the deferred's methods", function () {
        expect(Q.defer().resolve()).toBe(undefined);
        expect(Q.defer().reject()).toBe(undefined);
    });

});

describe("always next tick", function (done) {

    it("generated by `resolve`", function (done) {
        var turn = 0;
        Q().then(function () {
            expect(turn).toBe(1);
        }).done(done, done);
        turn++;
    });

    it("generated by `reject`", function (done) {
        var turn = 0;
        var promise = Q.reject().then(function () {
            expect(true).toBe(false);
        }, function () {
            expect(turn).toBe(1);
        }).done(done, done);
        turn++;
    });

});

describe("promises for objects", function () {

    describe("get", function () {

        it("fulfills a promise", function (done) {
            var deferred = Q.defer();
            deferred.resolve({a: 1});
            deferred.promise.get("a")
            .then(function (a) {
                expect(a).toBe(1);
            }).done(done, done);
        });

        it("propagates a rejection", function (done) {
            var exception = new Error("boo!");
            Q.try(function () {
                throw exception;
            })
            .get("a")
            .then(function () {
                expect("be").toBe("not to be");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            })
            .done(done, done);
        });

    });

    describe("invoke", function () {

        it("fulfills a promise", function (done) {
            var subject = {
                a: function a(value) {
                    this._a = value;
                    return 1 + value;
                }
            };

            Q(subject).invoke("a", 1).then(function (two) {
                expect(subject._a).toBe(1);
                expect(two).toBe(2);
            }).done(done, done);
        });

    });

    describe("send", function () {

        it("fulfills a promise", function (done) {
            var foo;
            var subject = {
                foo: function (_bar) {
                    return _bar;
                },
                bar: function (_foo, _bar) {
                    foo = _foo;
                    return this.foo(_bar);
                }
            };
            Q(subject).invoke("bar", 1, 2)
            .then(function (two) {
                expect(foo).toBe(1);
                expect(two).toBe(2);
            })
            .done(done, done);
        });

        it("is rejected for undefined method", function (done) {
            var subject = {};
            Q(subject)
            .invoke("foo")
            .then(function () {
                expect("here").toBe("not here");
            }, function () {
            })
            .done(done, done);
        });

        it("is rejected for undefined object", function (done) {
            Q()
            .invoke("foo")
            .then(function () {
                expect("here").toBe("not here");
            }, function () {
            })
            .done(done, done);
        });

    });

    describe("keys", function () {

        function Klass (a, b) {
            this.a = a;
            this.b = b;
        }
        Klass.prototype.notOwn = 1;

        it("fulfills a promise", function (done) {
            Q(new Klass(10, 20))
            .keys()
            .then(function (keys) {
                expect(keys.sort()).toEqual(["a", "b"]);
            })
            .done(done, done);
        });

    });

});

describe("inspect", function () {

    it("for a fulfilled promise", function () {
        expect(Q(10).inspect()).toEqual({
            state: "fulfilled",
            value: 10
        });
    });

    it("for a rejected promise", function () {
        var error = new Error("In your face.");
        var rejected = Q.reject(error);
        expect(rejected.inspect()).toEqual({
            state: "rejected",
            reason: error
        });
    });

    it("for a pending, unresolved promise", function () {
        var pending = Q.defer().promise;
        expect(pending.inspect()).toEqual({ state: "pending" });
    });

    it("for a promise resolved to a rejected promise", function () {
        var deferred = Q.defer();
        var error = new Error("Rejected!");
        var rejected = Q.reject(error);
        deferred.resolve(rejected);

        expect(deferred.promise.inspect()).toEqual({
            state: "rejected",
            reason: error
        });
    });

    it("for a promise resolved to a fulfilled promise", function () {
        var deferred = Q.defer();
        var fulfilled = Q(10);
        deferred.resolve(fulfilled);

        expect(deferred.promise.inspect()).toEqual({
            state: "fulfilled",
            value: 10
        });
    });

    it("for a promise resolved to a pending promise", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);

        expect(a.promise.inspect()).toEqual({ state: "pending" });
    });

});

describe("promises for functions", function () {

    describe("apply", function () {
        it("fulfills a promise using arguments", function (done) {
            Q(function (a, b, c) {
                return a + b + c;
            })
            .apply(void 0, [1, 2, 3])
            .then(function (sum) {
                expect(sum).toBe(6);
            })
            .done(done, done);
        });
    });

    describe("call", function () {
        it("fulfills a promise using arguments", function (done) {
            Q(function (a, b, c) {
                return a + b + c;
            })
            .call(void 0, 1, 2, 3)
            .then(function (sum) {
                expect(sum).toBe(6);
            })
            .done(done, done);
        });
    });

    describe("fbind", function () {

        it("accepts a promise for a function", function (done) {
            Q.fbind(Q(function (high, low) {
                return high - low;
            }))
            (2, 1)
            .then(function (difference) {
                expect(difference).toBe(1);
            })
            .done(done, done);
        });

        it("chains partial application on a promise for a function", function (done) {
            Q.fbind(function (a, b) {
                return a * b;
            }, 2)
            (3)
            .then(function (product) {
                expect(product).toBe(6);
            })
            .done(done, done);
        });

        it("returns a fulfilled promise", function (done) {
            var result = {};
            var bound = Q.fbind(function () {
                return result;
            });
            bound()
            .then(function (_result) {
                expect(_result).toBe(result);
            })
            .done(done, done);
        });

        it("returns a rejected promise from a thrown error", function (done) {
            var exception = new Error("Boo!");
            var bound = Q.fbind(function () {
                throw exception;
            });
            bound()
            .then(function () {
                expect("flying pigs").toBe("swillin' pigs");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            })
            .done(done, done);
        });

        it("passes arguments through", function (done) {
            var x = {}, y = {};
            var bound = Q.fbind(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            });
            bound(x, y).done(done, done);
        });

        it("passes and also partially applies arguments", function (done) {
            var x = {}, y = {};
            var bound = Q.fbind(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            }, x);
            bound(y).done(done, done);
        });

        it("doesn't bind `this`", function (done) {
            var theThis = { me: "this" };
            var bound = Q.fbind(function () {
                expect(this).toBe(theThis);
            });
            bound.call(theThis)
            .done(done, done);
        });

    });

    describe("method", function () {
        it("passes this and args, returns promise", function () {
            var object = {
                a: 10,
                b: 20,
                add: Q.function(function (c, d) {
                    return this.a + this.b + c + d;
                })
            };
            return object.add(30, 40).then(function (sum) {
                expect(sum).toBe(100);
            });
        });

    });

    describe("bind", function () {

        it("accepts a promise for a function", function (done) {
            Q(function (high, low) {
                return high - low;
            }).bind()
            (2, 1)
            .then(function (difference) {
                expect(difference).toBe(1);
            })
            .done(done, done);
        });

        it("chains partial application on a promise for a function", function (done) {
            Q(function (a, b) {
                return a * b;
            }).bind(null, 2)
            (3)
            .then(function (product) {
                expect(product).toBe(6);
            })
            .done(done, done);
        });

        it("returns a fulfilled promise", function (done) {
            var result = {};
            var bound = Q(function () {
                return result;
            }).bind();
            bound()
            .then(function (_result) {
                expect(_result).toBe(result);
            })
            .done(done, done);
        });

        it("returns a rejected promise from a thrown error", function (done) {
            var exception = new Error("Boo!");
            var bound = Q(function () {
                throw exception;
            }).bind();
            bound()
            .then(function () {
                expect("flying pigs").toBe("swillin' pigs");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            })
            .done(done, done);
        });

        it("passes arguments through", function (done) {
            var x = {}, y = {};
            var bound = Q(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            }).bind();
            bound(x, y).done(done, done);
        });

        it("passes and also partially applies arguments", function (done) {
            var x = {}, y = {};
            var bound = Q(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            }).bind(null, x);
            bound(y).done(done, done);
        });

    });
});

describe("promise states", function () {

    it("of fulfillment", function () {
        var promise = Q(10);
        expect(promise.isFulfilled()).toBe(true);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isPending()).toBe(false);
    });

    it("of rejection", function () {
        var error = new Error("Oh, snap.");
        var promise = Q.reject(error);
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(true);
        expect(promise.isPending()).toBe(false);
    });

    it("of rejection with a falsy value", function () {
        var promise = Q.reject(undefined);
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(true);
        expect(promise.isPending()).toBe(false);
    });

    it("of deferred", function () {
        var deferred = Q.defer();
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isPending()).toBe(true);
    });

    it("of deferred rejection", function () {
        var deferred = Q.defer();
        var rejection = Q.reject(new Error("Rejected!"));
        deferred.resolve(rejection);
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(true);
        expect(promise.isPending()).toBe(false);
    });

    it("of deferred fulfillment", function () {
        var deferred = Q.defer();
        deferred.resolve(10);
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(true);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isPending()).toBe(false);
    });

    it("of deferred deferred", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        var promise = a.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isPending()).toBe(true);
    });

    it("of isFulfilled side effects", function (done) {
        var deferred = Q.defer();
        var finished = false;

        var parentPromise = deferred.promise;

        var childPromise = parentPromise.then(function () {
            expect(parentPromise.isFulfilled()).toBe(true);
            expect(childPromise.isFulfilled()).toBe(false);

            return parentPromise.then(function (value) {
                asap(finish);
                return value + 1;
            });
        });

        deferred.resolve(1);

        function finish() {
            expect(childPromise.isPending()).toBe(false);
            expect(childPromise.isRejected()).toBe(false);
            expect(childPromise.isFulfilled()).toBe(true);
            expect(childPromise.inspect().value).toBe(2);
            done();
        }
    });

});

describe("propagation", function () {

    it("propagate through then with no callback", function (done) {
        Q(10)
        .then()
        .then(function (ten) {
            expect(ten).toBe(10);
        })
        .done(done, done);
    });

    it("propagate through then with modifying callback", function (done) {
        Q(10)
        .then(function (ten) {
            return ten + 10;
        })
        .then(function (twen) {
            expect(twen).toBe(20);
        })
        .done(done, done);
    });

    it("errback recovers from exception", function (done) {
        var error = new Error("Bah!");
        Q.reject(error)
        .then(null, function (_error) {
            expect(_error).toBe(error);
            return 10;
        })
        .then(function (value) {
            expect(value).toBe(10);
        })
        .done(done, done);
    });

    it("rejection propagates through then with no errback", function (done) {
        var error = new Error("Foolish mortals!");
        Q.reject(error)
        .then()
        .then(null, function (_error) {
            expect(_error).toBe(error);
        })
        .done(done, done);
    });

    it("rejection intercepted and rethrown", function (done) {
        var error = new Error("Foolish mortals!");
        var nextError = new Error("Silly humans!");
        Q.reject(error)
        .catch(function () {
            throw nextError;
        })
        .then(null, function (_error) {
            expect(_error).toBe(nextError);
        })
        .done(done, done);
    });

    it("resolution is forwarded through deferred promise", function (done) {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        b.resolve(10);
        a.promise.then(function (eh) {
            expect(eh).toBe(10);
        })
        .done(done, done);
    });

});

describe("all", function () {
    it("fulfills when passed an empty array", function (done) {
        Q.all([])
        .then(function (values) {
            expect(values).toEqual([]);
        })
        .done(done, done);
    });

    it("rejects after any constituent promise is rejected", function (done) {
        var toResolve = Q.defer(); // never resolve
        var toReject = Q.defer();
        var promises = [toResolve.promise, toReject.promise];
        var promise = Q.all(promises);

        toReject.reject(new Error("Rejected"));

        Q.delay(250)
        .then(function () {
            expect(promise.isRejected()).toBe(true);
        })
        .timeout(1000)
        .done(done, done);
    });

    it("resolves foreign thenables", function (done) {
        var normal = Q(1);
        var foreign = { then: function (f) { f(2); } };

        Q.all([normal, foreign])
        .then(function (result) {
            expect(result).toEqual([1, 2]);
        })
        .done(done, done);
    });

    it("calls thenables lazilly", function (done) {
        var promise = Q({then: function () {
            expect(true).toBe(false);
        }})
        Q.delay(10)
        .done(done, done);
    });

    it("fulfills when passed a sparse array", function (done) {
        var toResolve = Q.defer();
        var promises = [];
        promises[0] = Q(0);
        promises[2] = toResolve.promise;
        var promise = Q.all(promises);

        toResolve.resolve(2);

        return promise.then(function (result) {
            expect(result).toEqual([0, , 2]);
        })
        .done(done, done);
    });

    it("does not modify the input array", function (done) {
        var input = [Q(0), Q(1)];

        return Q.all(input).then(function (result) {
            expect(result).not.toEqual(input);
            expect(input).not.toEqual([0, 1]);
        })
        .done(done, done);
    });

});

describe("allSettled", function () {

    it("works on an empty array", function (done) {
        Q.allSettled([])
        .then(function (snapshots) {
            expect(snapshots).toEqual([]);
        })
        .done(done, done);
    });

    it("deals with a mix of non-promises and promises", function (done) {
        Q.allSettled([1, Q(2), Q.reject(3)])
        .then(function (snapshots) {
            expect(snapshots).toEqual([
                { state: "fulfilled", value: 1 },
                { state: "fulfilled", value: 2 },
                { state: "rejected", reason: 3 }
            ]);
        })
        .done(done, done);
    });

    it("is settled after every constituent promise is settled", function (done) {
        var toFulfill = Q.defer();
        var toReject = Q.defer();
        var promises = [toFulfill.promise, toReject.promise];
        var fulfilled;
        var rejected;

        Q.try(function () {
            toReject.reject();
            rejected = true;
        })
        .delay(15)
        .then(function () {
            toFulfill.resolve();
            fulfilled = true;
        });

        Q.allSettled(promises)
        .then(function () {
            expect(fulfilled).toBe(true);
            expect(rejected).toBe(true);
        })
        .done(done, done);
    });

    it("does not modify the input array", function (done) {
        var input = [1, Q(2), Q.reject(3)];

        Q.allSettled(input)
        .then(function (snapshots) {
            expect(snapshots).not.toBe(input);
            expect(snapshots).toEqual([
                { state: "fulfilled", value: 1 },
                { state: "fulfilled", value: 2 },
                { state: "rejected", reason: 3 }
            ]);
        })
        .done(done, done);
    });

});

describe("spread", function () {

    it("spreads values across arguments", function (done) {
        Q.spread([1, 2, 3], function (a, b) {
            expect(b).toBe(2);
        })
        .done(done, done);
    });

    it("spreads promises for arrays across arguments", function (done) {
        return Q([Q(10)])
        .spread(function (value) {
            expect(value).toBe(10);
        })
        .done(done, done);
    });

    it("spreads arrays of promises across arguments", function (done) {
        var deferredA = Q.defer();
        var deferredB = Q.defer();

        Q.spread(
            [deferredA.promise, deferredB.promise],
            function (a, b) {
                expect(a).toBe(10);
                expect(b).toBe(20);
            }
        )
        .done(done, done);

        Q.delay(5).then(function () {
            deferredA.resolve(10);
        });
        Q.delay(10).then(function () {
            deferredB.resolve(20);
        });

    });

    it("calls the errback when given a rejected promise", function (done) {
        var err = new Error();
        Q.spread([Q(10), Q.reject(err)],
            function () {
                expect(true).toBe(false);
            },
            function (actual) {
                expect(actual).toBe(err);
            }
        )
        .done(done, done);
    });

});

describe("finally", function (done) {

    var exception1 = new Error("boo!");
    var exception2 = new TypeError("evil!");

    describe("when the promise is fulfilled", function () {

        it("should call the callback", function (done) {
            var called = false;

            return Q("foo")
            .finally(function () {
                called = true;
            })
            .then(function () {
                expect(called).toBe(true);
            })
            .done(done, done);
        });

        it("should fulfill with the original value", function (done) {
            return Q("foo")
            .finally(function () {
                return "bar";
            })
            .then(function (result) {
                expect(result).toBe("foo");
            })
            .done(done, done);
        });

        describe("when the callback returns a promise", function () {

            describe("that is fulfilled", function () {

                it("should fulfill with the original reason after that promise resolves", function (done) {
                    var promise = Q.delay(250);

                    Q("foo")
                    .finally(function () {
                        return promise;
                    })
                    .then(function (result) {
                        expect(promise.isPending()).toBe(false);
                        expect(result).toBe("foo");
                    })
                    .done(done, done);
                });

            });

            describe("that is rejected", function () {
                it("should reject with this new rejection reason", function (done) {
                    return Q("foo")
                    .finally(function () {
                        return Q.reject(exception1);
                    })
                    .then(function () {
                        expect(false).toBe(true);
                    },
                    function (exception) {
                        expect(exception).toBe(exception1);
                    })
                    .done(done, done);
                });
            });

        });

        describe("when the callback throws an exception", function () {
            it("should reject with this new exception", function (done) {
                return Q("foo")
                .finally(function () {
                    throw exception1;
                })
                .then(function () {
                    expect(false).toBe(true);
                },
                function (exception) {
                    expect(exception).toBe(exception1);
                })
                .done(done, done);
            });
        });

    });

    describe("when the promise is rejected", function () {

        it("should call the callback", function (done) {
            var called = false;

            return Q.reject(exception1)
            .finally(function () {
                called = true;
            })
            .then(function () {
                expect(called).toBe(true);
            }, function () {
                expect(called).toBe(true);
            })
            .done(done, done);
        });

        it("should reject with the original reason", function (done) {
            return Q.reject(exception1)
            .finally(function () {
                return "bar";
            })
            .then(function () {
                expect(false).toBe(true);
            }, function (exception) {
                expect(exception).toBe(exception1);
            })
            .done(done, done);
        });

        describe("when the callback returns a promise", function () {

            describe("that is fulfilled", function () {

                it("should reject with the original reason after that promise resolves", function (done) {
                    var promise = Q.delay(250);

                    Q.reject(exception1)
                    .finally(function () {
                        return promise;
                    })
                    .then(function () {
                        expect(false).toBe(true);
                    }, function (exception) {
                        expect(exception).toBe(exception1);
                        expect(promise.isPending()).toBe(false);
                    })
                    .done(done, done);
                });

            });

            describe("that is rejected", function () {

                it("should reject with the new reason", function (done) {
                    Q.reject(exception1)
                    .finally(function () {
                        return Q.reject(exception2);
                    })
                    .then(function () {
                        expect(false).toBe(true);
                    }, function (exception) {
                        expect(exception).toBe(exception2);
                    })
                    .done(done, done);
                });

            });

        });

        describe("when the callback throws an exception", function () {

            it("should reject with this new exception", function (done) {
                Q.reject(exception1)
                .finally(function () {
                    throw exception2;
                })
                .then(function () {
                    expect(false).toBe(true);
                }, function (exception) {
                    expect(exception).toBe(exception2);
                })
                .done(done, done);
            });

        });

    });

});

describe("done", function () {

    describe("when the promise is fulfilled", function () {

        describe("and the callback does not throw", function () {

            it("should call the callback and return nothing", function (done) {
                var called = false;

                var promise = Q();

                var returnValue = promise.done(function () {
                    called = true;
                });

                promise.catch(function () {
                })
                .finally(function () {
                    expect(called).toBe(true);
                    expect(returnValue).toBe(undefined);
                })
                .done(done, done);
            });
        });

        describe("and the callback throws", function () {

            it("should rethrow that error in the next turn and return nothing", function (done) {
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("foo");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };

                var turn = 0;
                asap(function () {
                    ++turn;
                });

                var returnValue = Q().done(
                    function () {
                        throw "foo";
                    }
                );

                var deferred = Q.defer();
                Q.delay(100).then(deferred.reject);

                return deferred.promise.done(done, done);
            });

        });

    });

    describe("when the promise is rejected", function () {

        describe("and the errback handles it", function () {

            it("should call the errback and return nothing", function (done) {
                var called = false;

                var promise = Q.reject(new Error());

                var returnValue = promise.done(
                    function () { },
                    function () {
                        called = true;
                    }
                );

                promise
                .catch(function () {
                })
                .finally(function () {
                    expect(called).toBe(true);
                    expect(returnValue).toBe(undefined);
                })
                .done(done, done);
            });

        });

        describe("and the errback throws", function () {

            it("should rethrow that error in the next turn and return nothing", function (done) {
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("foo");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };

                var turn = 0;
                asap(function () {
                    ++turn;
                });

                var returnValue = Q.reject("bar").done(
                    null,
                    function () {
                        throw "foo";
                    }
                );

                var deferred = Q.defer();
                Q.delay(100).then(deferred.reject);

                deferred.promise.done(done, done);
            });
        });

        describe("and there is no errback", function () {

            it("should throw the original error in the next turn", function (done) {
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("bar");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };

                var turn = 0;
                asap(function () {
                    ++turn;
                });

                var returnValue = Q.reject("bar").done();

                var deferred = Q.defer();
                Q.delay(10).then(deferred.reject);

                deferred.promise.done(done, done);
            });

        });

    });

});

describe("timeout", function () {

    it("does nothing if the promise fulfills quickly", function (done) {
        Q.delay(10).timeout(200).done(done, done);
    });

    it("does nothing if the promise rejects quickly", function (done) {
        var goodError = new Error("haha!");
        Q.delay(10)
        .then(function () {
            throw goodError;
        })
        .timeout(200)
        .then(undefined, function (error) {
            expect(error).toBe(goodError);
        })
        .done(done, done);
    });

    it("rejects with a timeout error if the promise is too slow", function (done) {
        Q.delay(100)
        .timeout(10)
        .then(
            function () {
                expect(true).toBe(false);
            },
            function (error) {
                expect(/time/i.test(error.message)).toBe(true);
            }
        )
        .done(done, done);
    });

    it("rejects with a custom timeout error if the promise is too slow and msg was provided", function (done) {
        Q.delay(100)
        .timeout(10, "custom")
        .then(
            function () {
                expect(true).toBe(false);
            },
            function (error) {
                expect(/custom/i.test(error.message)).toBe(true);
            }
        )
        .done(done, done);
    });

});

describe("delay", function () {

    it("should delay fulfillment", function (done) {
        var promise = Q(5).delay(50);

        setTimeout(function () {
            expect(promise.isPending()).toBe(true);
        }, 40);

        promise.then(function () {
        })
        .done(done, done);
    });

    it("should not delay rejection", function (done) {
        var promise = Q.reject(5).delay(50);

        Q.delay(20)
        .then(function () {
            expect(promise.isPending()).toBe(false);
        })
        .done(done, done);
    });

    it("should treat a single argument as a time", function (done) {
        var promise = Q.delay(50);

        setTimeout(function () {
            expect(promise.isPending()).toBe(true);
        }, 40);

        promise.done(done, done);
    });

    it("should treat two arguments as a value + a time", function (done) {
        var promise = Q.delay("what", 50);

        setTimeout(function () {
            expect(promise.isPending()).toBe(true);
        }, 40);

        promise.then(function (value) {
            expect(value).toBe("what");
        })
        .done(done, done);
    });

    it("should delay after resolution", function (done) {
        var promise1 = Q.delay("what", 30);
        var promise2 = promise1.delay(30);

        setTimeout(function () {
            expect(promise1.isPending()).toBe(false);
            expect(promise2.isPending()).toBe(true);
        }, 40);

        promise2.then(function (value) {
            expect(value).toBe("what");
        })
        .done(done, done);
    });

});

describe("thenResolve", function () {

    describe("resolving with a non-thenable value", function () {

        it("returns a promise for that object once the promise is resolved", function (done) {
            var waited = false;
            Q.delay(20)
            .then(function () {
                waited = true;
            })
            .thenResolve("foo")
            .then(function (val) {
                expect(waited).toBe(true);
                expect(val).toBe("foo");
            })
            .done(done, done);
        });

        describe("based off a rejected promise", function () {

            it("does nothing, letting the rejection flow through", function (done) {
                Q.reject("boo")
                .thenResolve("foo")
                .then(
                    function () {
                        expect(true).toBe(false);
                    },
                    function (reason) {
                        expect(reason).toBe("boo");
                    }
                )
                .done(done, done);
            });

        });

    });

    describe("resolving with an promise", function () {

        it("returns a promise for the result of that promise once the promise is resolved", function (done) {

            var waited = false;
            Q.delay(20)
            .then(function () {
                waited = true;
            })
            .thenResolve(Q("foo"))
            .then(function (val) {
                expect(waited).toBe(true);
                expect(val).toBe("foo");
            })
            .done(done, done);
        });

    });

});

describe("thenReject", function () {

    describe("rejecting with a reason", function () {

        it("returns a promise rejected with that object once the original promise is resolved", function (done) {
            var waited = false;
            Q.delay(20)
            .then(function () {
                waited = true;
            })
            .thenReject("foo")
            .then(
                function () {
                    expect(true).toBe(false);
                },
                function (reason) {
                    expect(waited).toBe(true);
                    expect(reason).toBe("foo");
                }
            )
            .done(done, done);
        });

        describe("based off a rejected promise", function (done) {
            it("does nothing, letting the rejection flow through", function () {
                return Q.reject("boo")
                .thenResolve("foo")
                .then(
                    function () {
                        expect(true).toBe(false);
                    },
                    function (reason) {
                        expect(reason).toBe("boo");
                    }
                )
                .done(done, done);
            });
        });
    });

});

describe("thenables", function () {

    it("assimilates a thenable with fulfillment with resolve", function (done) {
        Q({
            then: function (resolved) {
                resolved(10);
            }
        })
        .then(function (ten) {
            expect(ten).toBe(10);
        })
        .then(function (undefined) {
            expect(undefined).toBe(void 0);
        })
        .done(done, done);
    });

    it("flows fulfillment into a promise pipeline", function (done) {
        Q({
            then: function (resolved) {
                resolved([10]);
            }
        })
        .get(0)
        .then(function (ten) {
            expect(ten).toBe(10);
        })
        .done(done, done);
    });

    it("assimilates an immediately-fulfilled thenable in allSettled", function (done) {
        Q.allSettled([
            {then: function (win) {
                win(10);
            }}
        ])
        .then(function (snapshots) {
            expect(snapshots).toEqual([{ state: "fulfilled", value: 10 }]);
        })
        .done(done, done);
    });

    it("assimilates an eventually-fulfilled thenable in allSettled", function (done) {
        Q.allSettled([
            {then: function (win) {
                setTimeout(function () {
                    win(10);
                }, 100);
            }}
        ])
        .then(function (snapshots) {
            expect(snapshots).toEqual([{ state: "fulfilled", value: 10 }]);
        })
        .done(done, done);
    });

});

describe("isPromise", function () {

    it("returns true if passed a promise", function () {
        expect(Q.isPromise(Q(10))).toBe(true);
    });

    it("returns false if not passed a promise", function () {
        expect(Q.isPromise(undefined)).toBe(false);
        expect(Q.isPromise(null)).toBe(false);
        expect(Q.isPromise(10)).toBe(false);
        expect(Q.isPromise("str")).toBe(false);
        expect(Q.isPromise("")).toBe(false);
        expect(Q.isPromise(true)).toBe(false);
        expect(Q.isPromise(false)).toBe(false);
        expect(Q.isPromise({})).toBe(false);
        expect(Q.isPromise({
            then: function () {}
        })).toBe(false);
        expect(Q.isPromise(function () {})).toBe(false);
    });

});

xdescribe("isThenable", function () {
    it("returns true if passed a promise like object", function () {
        expect(Q.isThenable(Q(10))).toBe(true);
        expect(Q.isThenable({
            then: function () {}
        })).toBe(true);
    });

    it("returns false if not passed a promise like object", function () {
        expect(Q.isThenable(undefined)).toBe(false);
        expect(Q.isThenable(null)).toBe(false);
        expect(Q.isThenable(10)).toBe(false);
        expect(Q.isThenable("str")).toBe(false);
        expect(Q.isThenable("")).toBe(false);
        expect(Q.isThenable(true)).toBe(false);
        expect(Q.isThenable(false)).toBe(false);
        expect(Q.isThenable({})).toBe(false);
        expect(Q.isThenable(function () {})).toBe(false);
    });
});

describe("promised", function () {
    var exception = new Error("That is not the meaning of life.");

    it("resolves promised arguments", function (done) {
        var sum = Q.promised(function add(a, b) {
            return a + b;
        });
        sum(Q(4), Q(5)).then(function (sum) {
            expect(sum).toBe(9);
        })
        .done(done, done);
    });

    it("resolves promised `this`", function (done) {
        var inc = Q.promised(function inc(a) {
            return this + a;
        });
        inc.call(Q(4), Q(5)).then(function (sum) {
            expect(sum).toBe(9);
        })
        .done(done, done);
    });

    it("is rejected if an argument is rejected", function (done) {
        var sum = Q.promised(function add(a, b) {
            return a + b;
        });
        sum(Q.reject(exception), Q(4)).then(function () {
            expect(4).toBe(42);
        }, function (_exception) {
            expect(_exception).toBe(exception);
        })
        .done(done, done);
    });

    it("is rejected if `this` is rejected", function (done) {
        var inc = Q.promised(function inc(a) {
            return this + a;
        });
        inc.call(Q.reject(exception), Q(4)).then(function () {
            expect(4).toBe(42);
        }, function (_exception) {
            expect(_exception).toBe(exception);
        })
        .done(done, done);
    });

});

it("computes a large sum without blowing the stack", function () {
    var array = [];
    var iters = 1000;
    for (var i = 1; i <= iters; i++) {
        array.push(i);
    }

    var result = array.reduce(function (promise, nextVal) {
        return promise.then(function (currentVal) {
            return Q(currentVal + nextVal);
        });
    }, Q(0));

    return result.then(function (value) {
        expect(value).toBe(iters * (iters + 1) / 2);
    });
});


